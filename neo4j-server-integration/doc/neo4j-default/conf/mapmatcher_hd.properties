# properties for map matching (offline and online map matching)

# search radius in meter
mapmatcher_hd.maxMatchingRadiusInMeter = 3
# initial search radius in meter
mapmatcher_hd.intialRadiusMeter = 5
# number of points for a valid initial segment's match
mapmatcher_hd.nrOfPointsForInitialMatch = 1
# maximum number of segments of a shortest path search
mapmatcher_hd.maxSegmentsForShortestPath = 20
# minimum number of track points
mapmatcher_hd.minNrOfPoints = 2
# minimum track length
mapmatcher_hd.minLength = 30
# minimum number of matching segments per section
mapmatcher_hd.minSegmentsPerSection = 3
# maximum tries to expand paths without any resulting extension 
mapmatcher_hd.maxCountLoopsWithoutPathExtension = 15
# envelope side length used to determine next valid track point for searching start segment
mapmatcher_hd.envelopeSideLengthForStartSegmentSearch = 30
# maximum number of best resulting paths with which will be processed preferable
mapmatcher_hd.maxNrOfBestPaths = 5
# delay of timeout scheduler in ms (internal)
mapmatcher_hd.timeout.delay = 1000
# timeout expiration delay of a map matching task in ms
mapmatcher_hd.timeout.expireTime = 3000
# timespan (in seconds) between trackpoints which defines if a given sampling interval is low
mapmatcher_hd.thresholdForLowSamplingsInSecs = 7
# for shortest path searches a track point will be identified creating a routed path to; in some cases this track point has a big GPS error so routing
# will not be successful; then the algorithm will try the next n points as routing targets;
# statistically this methodology results in worse paths for higher sampling intervals
mapmatcher_hd.thresholdSamplingIntervalInSecsForTryingFurtherPathSearches = 90

# In case of routing we won't route for parts of track which possible left the underlying graph. Usually such parts of track consist of a number of valid
# GPS points. In that case we want to skip routing and start a new path, which means we create a gap within the routing paths. On the other hand routing
# makes sense in case of GPS errors. For such parts of a track we have to consider only a few GPS points, possible partly invalid because GPS error.
# To differ those cases we need a threshold: the maximum number of points we want consider for routing (difference between last matched point and first
# point which determines a target segment for routing). If the number of points considered for routing exceed this threshold a new path will be created.
# In case of low sampled tracks this value will be automatically divided in half.
mapmatcher_hd.pointsDiffThresholdForSkipRouting = 5
# routing mode: possible values are: "car" / "bike" / "pedestrian" / "" ("" means no filtering of access types within routing, default is "car")
mapmatcher_hd.routingMode=car
# routing criteria: possible values are: "length" / "min_duration" / "current_duration" (default is "length")
mapmatcher_hd.routingCriteria=length
# routing algorithm: possible values are: "DIJKSTRA" / "ASTAR" (default is "DIJKSTRA")
mapmatcher_hd.routingAlgorithm=DIJKSTRA
#mapmatcher_hd.routingAlgorithm=ASTAR

# enable extended path matching: search path between two track points without routing
mapmatcher_hd.extendedPathMatching.enable=true
# maximum distance of path between two track points in meter
mapmatcher_hd.extendedPathMatching.maxDistance=400

# CSV logger for logging map matching statistics
mapmatcher_hd.csvLoggerName = 